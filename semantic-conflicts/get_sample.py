import sys
import os
import csv

def fetchJars():
    outputPath = os.getcwd()
    merge_scenarios_directory = outputPath.split("semantic-conflicts")[0]
    merge_scenarios_file = "results-only.csv"

    print("Starting getting jars...")
    parsedOutput = read_output(merge_scenarios_file)
    print(len(parsedOutput))
    new_output = ""
    # download the releases for the project moving them to the output directories
    for key in parsedOutput:
        # check if release was generated by the framework
        try:
            values = parsedOutput[key].split(",")
            commitSHA = values[1]
            new_output += get_version_for_commit(merge_scenarios_directory, commitSHA, "original", values)
            new_output += get_version_for_commit(merge_scenarios_directory, commitSHA, "transformed", values)
            new_output += get_version_for_commit(merge_scenarios_directory, commitSHA, "serialized", values)
        except Exception as e:
            print(e)
    create_final_output_file(outputPath, new_output)

def get_version_for_commit(outputPath, commitSHA, version, values):
    release = get_local_jars_for_commit(outputPath, commitSHA, version, values[0])
    base = get_all_jars_for_revision(release, "base")
    left = get_all_jars_for_revision(release, "left")
    right = get_all_jars_for_revision(release, "right")
    merge = get_all_jars_for_revision(release, "merge")
    return format_output(values, merge, left, right, base, version)

def create_final_output_file(outputPath, contents):
   with open(outputPath + "/results_semantic_study.csv", 'w') as outputFile:
        outputFile.write(contents)
        outputFile.close() 

def create_final_output_file_object(outputPath, contents):
   with open(outputPath + "/results_semantic_study.csv", mode='a+') as employee_file:
    employee_writer = csv.writer(employee_file, delimiter=';', quoting=csv.QUOTE_MINIMAL)
    employee_writer.writerow(contents)

def format_output(values, merge, left, right, base, version):
    if (len(values) > 0):
        jars_available = "true"
        if (merge == "" and base == "" and (left == "" or right == "")):
            jars_available = "false"
        if (version == "serialized"):
            first_target_class = values[5].split("|")[0].rsplit('.',1)[0]
            values[5] = values[5] +" | "+first_target_class+".SerializedObjectSupporter"
            print(first_target_class)
        return values[0]+","+jars_available+","+values[1]+","+values[2]+","+values[3]+","+values[4]+","+values[5]+","+values[6]+","+values[7]+","+values[8]+","+base+","+left+","+right+","+merge+","+version+",\n"
    else:
        return "";

def read_output(outputPath):
    try:
        fo = open(outputPath)
        file = fo.read()
        fo.close()

        fileOutLines = file.split("\n")
        return parse_output(fileOutLines)
    except Exception as e:
        print(e)

def parse_output(lines):
    result = {}
    for line in lines[1:]:
        cells = line.split(",")
        if (len (cells) > 1):
            result[cells[1]+"-"+cells[5]+"-"+cells[6]] = line
    return result

def get_local_jars(path, directory):
    command = 'find '+str(path)+ ' -name ' +str(directory)
    return os.popen(command).read().split("\n")[:-1][0]

def get_local_jars_for_commit(path, commit, directory, projectName):
    command = 'find '+str(path)+ ' -name ' +str(commit)
    return get_local_jars(path+projectName+"/"+commit+"/", directory)

def get_all_jars_for_revision(path, revision):
    command = 'find '+str(path)+ '/'+str(revision)+' -name "*.jar"'
    jars = os.popen(command).read().split("\n")[:-1]
    all_jars = ""
    for one_jar in jars:
        all_jars += str(one_jar)+str(":")
    return all_jars

fetchJars()
